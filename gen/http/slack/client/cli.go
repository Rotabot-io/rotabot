// Code generated by goa v3.12.1, DO NOT EDIT.
//
// Slack HTTP client CLI support package
//
// Command:
// $ goa gen github.com/rotabot-io/rotabot/design

package client

import (
	"encoding/json"
	"fmt"
	"strconv"

	slack "github.com/rotabot-io/rotabot/gen/slack"
)

// BuildCommandsPayload builds the payload for the Slack Commands endpoint from
// CLI flags.
func BuildCommandsPayload(slackCommandsBody string, slackCommandsSignature string, slackCommandsTimestamp string) (*slack.Command, error) {
	var err error
	var body CommandsRequestBody
	{
		err = json.Unmarshal([]byte(slackCommandsBody), &body)
		if err != nil {
			return nil, fmt.Errorf("invalid JSON for body, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"api_app_id\": \"A123456\",\n      \"channel_id\": \"C2147483705\",\n      \"channel_name\": \"test\",\n      \"command\": \"/weather\",\n      \"enterprise_id\": \"E0001\",\n      \"enterprise_name\": \"Globular Construct Inc\",\n      \"is_enterprise_install\": true,\n      \"response_url\": \"https://hooks.slack.com/commands/1234/5678\",\n      \"team_domain\": \"example\",\n      \"team_id\": \"T0001\",\n      \"text\": \"94070\",\n      \"token\": \"gIkuvaNzQIHg97ATvDxqgjtO\",\n      \"trigger_id\": \"13345224609.738474920.8088930838d88f008e0\",\n      \"user_id\": \"U2147483697\",\n      \"user_name\": \"Steve\"\n   }'")
		}
	}
	var signature *string
	{
		if slackCommandsSignature != "" {
			signature = &slackCommandsSignature
		}
	}
	var timestamp *int64
	{
		if slackCommandsTimestamp != "" {
			val, err := strconv.ParseInt(slackCommandsTimestamp, 10, 64)
			timestamp = &val
			if err != nil {
				return nil, fmt.Errorf("invalid value for timestamp, must be INT64")
			}
		}
	}
	v := &slack.Command{
		Token:               body.Token,
		Command:             body.Command,
		Text:                body.Text,
		ResponseURL:         body.ResponseURL,
		TriggerID:           body.TriggerID,
		UserID:              body.UserID,
		UserName:            body.UserName,
		TeamID:              body.TeamID,
		TeamDomain:          body.TeamDomain,
		EnterpriseID:        body.EnterpriseID,
		EnterpriseName:      body.EnterpriseName,
		IsEnterpriseInstall: body.IsEnterpriseInstall,
		ChannelID:           body.ChannelID,
		ChannelName:         body.ChannelName,
		APIAppID:            body.APIAppID,
	}
	v.Signature = signature
	v.Timestamp = timestamp

	return v, nil
}

// BuildEventsPayload builds the payload for the Slack Events endpoint from CLI
// flags.
func BuildEventsPayload(slackEventsBody string, slackEventsSignature string, slackEventsTimestamp string) (*slack.Event, error) {
	var err error
	var body EventsRequestBody
	{
		err = json.Unmarshal([]byte(slackEventsBody), &body)
		if err != nil {
			return nil, fmt.Errorf("invalid JSON for body, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"api_app_id\": \"A123456\",\n      \"challenge\": \"randomstring\",\n      \"event\": {\n         \"type\": \"Architecto cumque optio eius.\"\n      },\n      \"team_id\": \"T0001\",\n      \"token\": \"gIkuvaNzQIHg97ATvDxqgjtO\",\n      \"type\": \"event_callback\"\n   }'")
		}
	}
	var signature *string
	{
		if slackEventsSignature != "" {
			signature = &slackEventsSignature
		}
	}
	var timestamp *int64
	{
		if slackEventsTimestamp != "" {
			val, err := strconv.ParseInt(slackEventsTimestamp, 10, 64)
			timestamp = &val
			if err != nil {
				return nil, fmt.Errorf("invalid value for timestamp, must be INT64")
			}
		}
	}
	v := &slack.Event{
		Token:     body.Token,
		TeamID:    body.TeamID,
		Challenge: body.Challenge,
		Type:      body.Type,
		APIAppID:  body.APIAppID,
	}
	if body.Event != nil {
		v.Event = &struct {
			Type *string
		}{
			Type: body.Event.Type,
		}
	}
	v.Signature = signature
	v.Timestamp = timestamp

	return v, nil
}
