// Code generated by goa v3.13.2, DO NOT EDIT.
//
// Slack HTTP server types
//
// Command:
// $ goa gen github.com/rotabot-io/rotabot/design

package server

import (
	slack "github.com/rotabot-io/rotabot/gen/slack"
	goa "goa.design/goa/v3/pkg"
)

// CommandsRequestBody is the type of the "Slack" service "Commands" endpoint
// HTTP request body.
type CommandsRequestBody struct {
	Token               *string `form:"token,omitempty" json:"token,omitempty" xml:"token,omitempty"`
	Command             *string `form:"command,omitempty" json:"command,omitempty" xml:"command,omitempty"`
	Text                *string `form:"text,omitempty" json:"text,omitempty" xml:"text,omitempty"`
	ResponseURL         *string `form:"response_url,omitempty" json:"response_url,omitempty" xml:"response_url,omitempty"`
	TriggerID           *string `form:"trigger_id,omitempty" json:"trigger_id,omitempty" xml:"trigger_id,omitempty"`
	UserID              *string `form:"user_id,omitempty" json:"user_id,omitempty" xml:"user_id,omitempty"`
	UserName            *string `form:"user_name,omitempty" json:"user_name,omitempty" xml:"user_name,omitempty"`
	TeamID              *string `form:"team_id,omitempty" json:"team_id,omitempty" xml:"team_id,omitempty"`
	TeamDomain          *string `form:"team_domain,omitempty" json:"team_domain,omitempty" xml:"team_domain,omitempty"`
	EnterpriseID        *string `form:"enterprise_id,omitempty" json:"enterprise_id,omitempty" xml:"enterprise_id,omitempty"`
	EnterpriseName      *string `form:"enterprise_name,omitempty" json:"enterprise_name,omitempty" xml:"enterprise_name,omitempty"`
	IsEnterpriseInstall *bool   `form:"is_enterprise_install,omitempty" json:"is_enterprise_install,omitempty" xml:"is_enterprise_install,omitempty"`
	ChannelID           *string `form:"channel_id,omitempty" json:"channel_id,omitempty" xml:"channel_id,omitempty"`
	ChannelName         *string `form:"channel_name,omitempty" json:"channel_name,omitempty" xml:"channel_name,omitempty"`
	APIAppID            *string `form:"api_app_id,omitempty" json:"api_app_id,omitempty" xml:"api_app_id,omitempty"`
}

// EventsRequestBody is the type of the "Slack" service "Events" endpoint HTTP
// request body.
type EventsRequestBody struct {
	Token     *string `form:"token,omitempty" json:"token,omitempty" xml:"token,omitempty"`
	TeamID    *string `form:"team_id,omitempty" json:"team_id,omitempty" xml:"team_id,omitempty"`
	Challenge *string `form:"challenge,omitempty" json:"challenge,omitempty" xml:"challenge,omitempty"`
	Type      *string `form:"type,omitempty" json:"type,omitempty" xml:"type,omitempty"`
	APIAppID  *string `form:"api_app_id,omitempty" json:"api_app_id,omitempty" xml:"api_app_id,omitempty"`
	// The actual event information
	Event *struct {
		Type *string `form:"type" json:"type" xml:"type"`
	} `form:"event,omitempty" json:"event,omitempty" xml:"event,omitempty"`
}

// MessageActionsRequestBody is the type of the "Slack" service
// "MessageActions" endpoint HTTP request body.
type MessageActionsRequestBody struct {
	Payload []byte `form:"payload,omitempty" json:"payload,omitempty" xml:"payload,omitempty"`
}

// EventsResponseBody is the type of the "Slack" service "Events" endpoint HTTP
// response body.
type EventsResponseBody struct {
	Challenge *string `form:"challenge,omitempty" json:"challenge,omitempty" xml:"challenge,omitempty"`
}

// MessageActionsResponseBody is the type of the "Slack" service
// "MessageActions" endpoint HTTP response body.
type MessageActionsResponseBody struct {
	ResponseAction *string           `form:"response_action,omitempty" json:"response_action,omitempty" xml:"response_action,omitempty"`
	View           any               `form:"view,omitempty" json:"view,omitempty" xml:"view,omitempty"`
	Errors         map[string]string `form:"errors,omitempty" json:"errors,omitempty" xml:"errors,omitempty"`
}

// NewEventsResponseBody builds the HTTP response body from the result of the
// "Events" endpoint of the "Slack" service.
func NewEventsResponseBody(res *slack.EventResponse) *EventsResponseBody {
	body := &EventsResponseBody{
		Challenge: res.Challenge,
	}
	return body
}

// NewMessageActionsResponseBody builds the HTTP response body from the result
// of the "MessageActions" endpoint of the "Slack" service.
func NewMessageActionsResponseBody(res *slack.ActionResponse) *MessageActionsResponseBody {
	body := &MessageActionsResponseBody{
		ResponseAction: res.ResponseAction,
		View:           res.View,
	}
	if res.Errors != nil {
		body.Errors = make(map[string]string, len(res.Errors))
		for key, val := range res.Errors {
			tk := key
			tv := val
			body.Errors[tk] = tv
		}
	}
	return body
}

// NewCommandsCommand builds a Slack service Commands endpoint payload.
func NewCommandsCommand(body *CommandsRequestBody, signature string, timestamp int64) *slack.Command {
	v := &slack.Command{
		Token:               *body.Token,
		Command:             *body.Command,
		Text:                body.Text,
		ResponseURL:         body.ResponseURL,
		TriggerID:           *body.TriggerID,
		UserID:              *body.UserID,
		UserName:            body.UserName,
		TeamID:              *body.TeamID,
		TeamDomain:          body.TeamDomain,
		EnterpriseID:        body.EnterpriseID,
		EnterpriseName:      body.EnterpriseName,
		IsEnterpriseInstall: body.IsEnterpriseInstall,
		ChannelID:           *body.ChannelID,
		ChannelName:         body.ChannelName,
		APIAppID:            body.APIAppID,
	}
	v.Signature = signature
	v.Timestamp = timestamp

	return v
}

// NewEventsEvent builds a Slack service Events endpoint payload.
func NewEventsEvent(body *EventsRequestBody, signature string, timestamp int64) *slack.Event {
	v := &slack.Event{
		Token:     *body.Token,
		TeamID:    *body.TeamID,
		Challenge: body.Challenge,
		Type:      *body.Type,
		APIAppID:  *body.APIAppID,
	}
	if body.Event != nil {
		v.Event = &struct {
			Type *string
		}{
			Type: body.Event.Type,
		}
	}
	v.Signature = signature
	v.Timestamp = timestamp

	return v
}

// NewMessageActionsAction builds a Slack service MessageActions endpoint
// payload.
func NewMessageActionsAction(body *MessageActionsRequestBody, signature string, timestamp int64) *slack.Action {
	v := &slack.Action{
		Payload: body.Payload,
	}
	v.Signature = signature
	v.Timestamp = timestamp

	return v
}

// ValidateCommandsRequestBody runs the validations defined on
// CommandsRequestBody
func ValidateCommandsRequestBody(body *CommandsRequestBody) (err error) {
	if body.Token == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("token", "body"))
	}
	if body.Command == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("command", "body"))
	}
	if body.TriggerID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("trigger_id", "body"))
	}
	if body.UserID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("user_id", "body"))
	}
	if body.TeamID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("team_id", "body"))
	}
	if body.ChannelID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("channel_id", "body"))
	}
	return
}

// ValidateEventsRequestBody runs the validations defined on EventsRequestBody
func ValidateEventsRequestBody(body *EventsRequestBody) (err error) {
	if body.Token == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("token", "body"))
	}
	if body.TeamID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("team_id", "body"))
	}
	if body.Type == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("type", "body"))
	}
	if body.APIAppID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("api_app_id", "body"))
	}
	return
}

// ValidateMessageActionsRequestBody runs the validations defined on
// MessageActionsRequestBody
func ValidateMessageActionsRequestBody(body *MessageActionsRequestBody) (err error) {
	if body.Payload == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("payload", "body"))
	}
	return
}
